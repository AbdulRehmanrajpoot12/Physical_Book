"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[4047],{6255(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1/python-agents-rclpy","title":"Python Agents & rclpy: Connecting AI Logic to ROS 2","description":"Understanding how to create Python-based agents that communicate with ROS 2 nodes using the rclpy client library","source":"@site/docs/module-1/python-agents-rclpy.md","sourceDirName":"module-1","slug":"/module-1/python-agents-rclpy","permalink":"/Physical_Book/docs/module-1/python-agents-rclpy","draft":false,"unlisted":false,"editUrl":"https://github.com/AbdulRehmanrajpoot12/Physical_Book/tree/main/docs/module-1/python-agents-rclpy.md","tags":[],"version":"current","frontMatter":{"title":"Python Agents & rclpy: Connecting AI Logic to ROS 2","sidebar_label":"Python Agents & rclpy","description":"Understanding how to create Python-based agents that communicate with ROS 2 nodes using the rclpy client library","slug":"/module-1/python-agents-rclpy"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Basics","permalink":"/Physical_Book/docs/module-1/ros2-basics"},"next":{"title":"URDF for Humanoids","permalink":"/Physical_Book/docs/module-1/urdf-humanoids"}}');var i=r(4848),t=r(8453);const o={title:"Python Agents & rclpy: Connecting AI Logic to ROS 2",sidebar_label:"Python Agents & rclpy",description:"Understanding how to create Python-based agents that communicate with ROS 2 nodes using the rclpy client library",slug:"/module-1/python-agents-rclpy"},a="Python Agents & rclpy: Connecting AI Logic to ROS 2",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"Creating Python Nodes with rclpy",id:"creating-python-nodes-with-rclpy",level:2},{value:"Basic Node Structure",id:"basic-node-structure",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Topics and Publish/Subscribe Pattern",id:"topics-and-publishsubscribe-pattern",level:2},{value:"Creating a Publisher",id:"creating-a-publisher",level:3},{value:"Creating a Subscriber",id:"creating-a-subscriber",level:3},{value:"Services and Request/Response Pattern",id:"services-and-requestresponse-pattern",level:2},{value:"Creating a Service Server",id:"creating-a-service-server",level:3},{value:"Creating a Service Client",id:"creating-a-service-client",level:3},{value:"Humanoid Data Flow Example",id:"humanoid-data-flow-example",level:2},{value:"AI Decision Node",id:"ai-decision-node",level:3},{value:"Best Practices for Python AI Agents",id:"best-practices-for-python-ai-agents",level:2},{value:"1. Proper Error Handling",id:"1-proper-error-handling",level:3},{value:"2. Efficient Message Handling",id:"2-efficient-message-handling",level:3},{value:"3. Resource Management",id:"3-resource-management",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"python-agents--rclpy-connecting-ai-logic-to-ros-2",children:"Python Agents & rclpy: Connecting AI Logic to ROS 2"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create Python nodes that communicate with ROS 2 using rclpy"}),"\n",(0,i.jsx)(n.li,{children:"Implement publishers and subscribers in Python"}),"\n",(0,i.jsx)(n.li,{children:"Design services and clients in Python"}),"\n",(0,i.jsx)(n.li,{children:"Understand how to integrate AI agents with ROS 2 nodes"}),"\n",(0,i.jsx)(n.li,{children:"Apply communication patterns to humanoid robot data flow"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,i.jsx)(n.p,{children:"rclpy is the Python client library for ROS 2, providing a Pythonic interface to ROS 2 concepts. It allows Python developers to create ROS 2 nodes, publish and subscribe to topics, provide and call services, and work with actions. This makes it ideal for implementing AI agents that need to interact with robotic systems."}),"\n",(0,i.jsx)(n.p,{children:"Python is particularly well-suited for AI and machine learning applications, making rclpy a crucial bridge between AI logic and robotic hardware."}),"\n",(0,i.jsx)(n.h2,{id:"creating-python-nodes-with-rclpy",children:"Creating Python Nodes with rclpy"}),"\n",(0,i.jsx)(n.h3,{id:"basic-node-structure",children:"Basic Node Structure"}),"\n",(0,i.jsx)(n.p,{children:"A basic ROS 2 node in Python follows this structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass MyNode(Node):\r\n    def __init__(self):\r\n        super().__init__('node_name')\r\n        # Initialize node components here\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = MyNode()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"ROS 2 nodes have a well-defined lifecycle:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Initialization: The node is created and configured"}),"\n",(0,i.jsx)(n.li,{children:"Execution: The node runs and processes callbacks"}),"\n",(0,i.jsx)(n.li,{children:"Shutdown: The node is properly cleaned up"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"topics-and-publishsubscribe-pattern",children:"Topics and Publish/Subscribe Pattern"}),"\n",(0,i.jsx)(n.p,{children:"The publish/subscribe pattern is fundamental to ROS 2 communication. Publishers send messages to topics, and subscribers receive messages from topics. This enables asynchronous, decoupled communication between nodes."}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-publisher",children:"Creating a Publisher"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass PublisherNode(Node):\r\n    def __init__(self):\r\n        super().__init__('publisher_node')\r\n        self.publisher_ = self.create_publisher(String, 'topic_name', 10)\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n        self.i = 0\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = f'Hello World: {self.i}'\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\r\n        self.i += 1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    publisher_node = PublisherNode()\r\n    rclpy.spin(publisher_node)\r\n    publisher_node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-subscriber",children:"Creating a Subscriber"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass SubscriberNode(Node):\r\n    def __init__(self):\r\n        super().__init__('subscriber_node')\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'topic_name',\r\n            self.listener_callback,\r\n            10)\r\n        self.subscription  # prevent unused variable warning\r\n\r\n    def listener_callback(self, msg):\r\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    subscriber_node = SubscriberNode()\r\n    rclpy.spin(subscriber_node)\r\n    subscriber_node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"services-and-requestresponse-pattern",children:"Services and Request/Response Pattern"}),"\n",(0,i.jsx)(n.p,{children:"Services provide synchronous communication between nodes. A service client sends a request to a service server, which processes the request and returns a response."}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-service-server",children:"Creating a Service Server"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import AddTwoInts\r\nimport rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass ServiceServerNode(Node):\r\n    def __init__(self):\r\n        super().__init__('service_server_node')\r\n        self.srv = self.create_service(\r\n            AddTwoInts,\r\n            'add_two_ints',\r\n            self.add_two_ints_callback\r\n        )\r\n\r\n    def add_two_ints_callback(self, request, response):\r\n        response.sum = request.a + request.b\r\n        self.get_logger().info(\r\n            f'Incoming request: a={request.a}, b={request.b}, sum={response.sum}'\r\n        )\r\n        return response\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    service_server_node = ServiceServerNode()\r\n    rclpy.spin(service_server_node)\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"creating-a-service-client",children:"Creating a Service Client"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from example_interfaces.srv import AddTwoInts\r\nimport rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass ServiceClientNode(Node):\r\n    def __init__(self):\r\n        super().__init__('service_client_node')\r\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\r\n        while not self.cli.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('Service not available, waiting again...')\r\n        self.req = AddTwoInts.Request()\r\n\r\n    def send_request(self, a, b):\r\n        self.req.a = a\r\n        self.req.b = b\r\n        self.future = self.cli.call_async(self.req)\r\n        rclpy.spin_until_future_complete(self, self.future)\r\n        return self.future.result()\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    service_client_node = ServiceClientNode()\r\n\r\n    response = service_client_node.send_request(1, 2)\r\n    service_client_node.get_logger().info(f'Result: {response.sum}')\r\n\r\n    service_client_node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"humanoid-data-flow-example",children:"Humanoid Data Flow Example"}),"\n",(0,i.jsx)(n.p,{children:"In humanoid robotics, data flows between various components using ROS 2 communication patterns. Here's an example of how an AI agent might interact with a humanoid robot:"}),"\n",(0,i.jsx)(n.h3,{id:"ai-decision-node",children:"AI Decision Node"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom geometry_msgs.msg import Twist\r\nfrom std_msgs.msg import String\r\n\r\nclass AIDecisionNode(Node):\r\n    def __init__(self):\r\n        super().__init__('ai_decision_node')\r\n\r\n        # Subscribe to sensor data\r\n        self.sensor_subscription = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.joint_state_callback,\r\n            10\r\n        )\r\n\r\n        # Subscribe to camera data\r\n        self.camera_subscription = self.create_subscription(\r\n            String,  # Simplified - in reality, this would be sensor_msgs/Image\r\n            'camera_data',\r\n            self.camera_callback,\r\n            10\r\n        )\r\n\r\n        # Publish commands to robot\r\n        self.cmd_publisher = self.create_publisher(\r\n            Twist,\r\n            'cmd_vel',\r\n            10\r\n        )\r\n\r\n        # AI processing timer\r\n        self.timer = self.create_timer(0.1, self.ai_processing_callback)\r\n\r\n        # Internal state\r\n        self.joint_states = None\r\n        self.camera_data = None\r\n\r\n    def joint_state_callback(self, msg):\r\n        self.joint_states = msg\r\n        self.get_logger().info(f'Received joint states: {len(msg.name)} joints')\r\n\r\n    def camera_callback(self, msg):\r\n        self.camera_data = msg\r\n        self.get_logger().info('Received camera data')\r\n\r\n    def ai_processing_callback(self):\r\n        # Simple AI decision making\r\n        if self.joint_states and self.camera_data:\r\n            # Analyze sensor data and make decisions\r\n            cmd_msg = Twist()\r\n            cmd_msg.linear.x = 0.5  # Move forward\r\n            cmd_msg.angular.z = 0.0  # No rotation\r\n\r\n            # Publish command\r\n            self.cmd_publisher.publish(cmd_msg)\r\n            self.get_logger().info('Published movement command')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    ai_node = AIDecisionNode()\r\n    rclpy.spin(ai_node)\r\n    ai_node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-python-ai-agents",children:"Best Practices for Python AI Agents"}),"\n",(0,i.jsx)(n.h3,{id:"1-proper-error-handling",children:"1. Proper Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.exceptions import ParameterNotDeclaredException\r\n\r\nclass RobustAINode(Node):\r\n    def __init__(self):\r\n        super().__init__('robust_ai_node')\r\n\r\n        # Declare parameters with defaults\r\n        self.declare_parameter('ai_model_path', '/default/path/model.pkl')\r\n\r\n        try:\r\n            model_path = self.get_parameter('ai_model_path').value\r\n            self.load_ai_model(model_path)\r\n        except ParameterNotDeclaredException:\r\n            self.get_logger().error('AI model path parameter not declared')\r\n\r\n    def load_ai_model(self, path):\r\n        try:\r\n            # Load your AI model here\r\n            self.get_logger().info(f'Loading AI model from {path}')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Failed to load AI model: {e}')\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-efficient-message-handling",children:"2. Efficient Message Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, HistoryPolicy, ReliabilityPolicy\r\n\r\nclass EfficientNode(Node):\r\n    def __init__(self):\r\n        super().__init__('efficient_node')\r\n\r\n        # Configure QoS for different types of data\r\n        sensor_qos = QoSProfile(\r\n            history=HistoryPolicy.KEEP_LAST,\r\n            depth=1,\r\n            reliability=ReliabilityPolicy.BEST_EFFORT\r\n        )\r\n\r\n        self.sensor_subscription = self.create_subscription(\r\n            JointState,\r\n            'joint_states',\r\n            self.sensor_callback,\r\n            sensor_qos\r\n        )\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-resource-management",children:"3. Resource Management"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class ResourceManagedNode(Node):\r\n    def __init__(self):\r\n        super().__init__('resource_managed_node')\r\n        self.ai_model = None\r\n        self.initialize_resources()\r\n\r\n    def initialize_resources(self):\r\n        try:\r\n            # Initialize AI model and other resources\r\n            self.get_logger().info('Initializing AI resources')\r\n        except Exception as e:\r\n            self.get_logger().error(f'Failed to initialize resources: {e}')\r\n\r\n    def destroy_node(self):\r\n        # Clean up resources before destroying node\r\n        if self.ai_model:\r\n            # Clean up AI model\r\n            self.ai_model = None\r\n        super().destroy_node()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"Python agents using rclpy provide a powerful way to connect AI logic with ROS 2 systems. The publish/subscribe pattern enables asynchronous communication between components, while services provide synchronous request/response interactions. For humanoid robotics applications, these patterns allow AI agents to process sensor data and generate appropriate commands for robot control."}),"\n",(0,i.jsx)(n.p,{children:"The examples in this chapter demonstrate how to create robust Python nodes that can serve as the bridge between sophisticated AI algorithms and the physical robot systems they control. The next chapter will explore how to describe robot structures using URDF, which is essential for humanoid robots."}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Continue to ",(0,i.jsx)(n.a,{href:"/Physical_Book/docs/module-1/urdf-humanoids",children:"URDF for Humanoids"})," to learn how to describe robot structures"]}),"\n",(0,i.jsxs)(n.li,{children:["Review ",(0,i.jsx)(n.a,{href:"/Physical_Book/docs/module-1/ros2-basics",children:"ROS 2 Basics"})," for fundamental concepts"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>o,x:()=>a});var s=r(6540);const i={},t=s.createContext(i);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);